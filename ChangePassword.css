package repository

import (
	// "skyfox/bookings/database/connection"
	"context"
	"errors"
	"fmt"
	"skyfox/bookings/database/common"
	"skyfox/bookings/model"
	ae "skyfox/error"

	"gorm.io/gorm"
)

type userRepository struct {
	*common.BaseDB
}

func NewUserRepository(db *common.BaseDB) *userRepository {
	return &userRepository{
		BaseDB: db,
	}
}

func (repo userRepository) FindByUsername(ctx context.Context, username string) (model.User, error) {
	var user model.User

	db, cancel := repo.WithContext(ctx)
	defer cancel()

	if result := db.Where("username = ?", username).First(&user); result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return model.User{}, nil
		}
		return model.User{}, ae.InternalServerError("InternalServerError", fmt.Sprintf("something went wrong"),
			fmt.Errorf("something went wrong %v", result.Error))
	}

	return user, nil
}

func (repo userRepository) Create(ctx context.Context, user *model.User) error {

	db, cancel := repo.WithContext(ctx)
	defer cancel()

	result := db.Create(user)

	if result.Error != nil {
		return ae.UnProcessableError("UserCreationFailed", "User creation failed due to unknown reason", result.Error)
	}
	return nil
}




package service

import (
	"context"
	"skyfox/bookings/model"
)

type UserRepository interface {
	FindByUsername(ctx context.Context, username string) (model.User, error)
	Create(ctx context.Context, user *model.User) error
}

type userService struct {
	userRepo UserRepository
}

func NewUserService(userRepository UserRepository) *userService {
	return &userService{
		userRepo: userRepository,
	}
}

func (s *userService) UserDetails(ctx context.Context, username string) (model.User, error) {

	user, err := s.userRepo.FindByUsername(ctx, username)
	if err != nil {
		return model.User{}, err
	}
	return user, nil
}












package controller

import (
	"context"
	"net/http"
	"skyfox/bookings/model"
	ae "skyfox/error"

	"github.com/gin-gonic/gin"
)

type UserService interface {
	UserDetails(context.Context, string) (model.User, error)
}

type UserController struct {
	userService UserService
}

func NewUserController(userService UserService) *UserController {
	return &UserController{
		userService: userService,
	}
}

// login godoc
//
//		@Summary		Login
//		@Description	login
//		@Tags			login
//		@Accept			json
//		@Produce		json
//	 @param Authorization header string true "Enter basic auth"
//		@Success		200	{string}	string
//		@Failure		401	{object}	ae.AppError
//		@Failure		404	{object}	ae.AppError
//		@Failure		500	{object}	ae.AppError
//		@Router			/login [get]
func (uh *UserController) Login(c *gin.Context) {

	username, _, _ := c.Request.BasicAuth()

	user, err := uh.userService.UserDetails(c.Request.Context(), username)
	if err != nil {
		appError := err.(*ae.AppError)
		c.AbortWithStatusJSON(appError.HTTPCode(), appError)
		return
	}

	c.JSON(http.StatusOK, user.Username)
}







package server

import (
	"fmt"
	"net/http"
	"time"

	"skyfox/bookings/constants"
	"skyfox/bookings/controller"
	"skyfox/bookings/database/connection"
	database "skyfox/bookings/database/seed"
	"skyfox/bookings/repository"
	"skyfox/bookings/service"
	"skyfox/common/logger"
	"skyfox/common/middleware/cors"
	"skyfox/common/middleware/security"
	"skyfox/common/middleware/validator"
	appConf "skyfox/config"
	movieservice "skyfox/movieservice/movie_gateway"

	ginzap "github.com/gin-contrib/zap"
	"github.com/gin-gonic/gin"
	"github.com/gin-gonic/gin/binding"

	_ "skyfox/docs" //indirect

	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

func Init(cfg appConf.AppConfig) error {

	logger.InitAppLogger(cfg.Logger)

	handler := connection.NewDBHandler(cfg.Database)
	db := handler.Instance()

	movieGateway := movieservice.NewMovieGateway(cfg.MovieGateway)

	// instantiate repositories
	bookingRepository := repository.NewBookingRepository(db)
	showRepository := repository.NewShowRepository(db)
	userRepository := repository.NewUserRepository(db)
	

	database.SeedDB(userRepository)

	// instantiate all services
	bookingService := service.NewBookingService(bookingRepository, showRepository)
	showService := service.NewShowService(showRepository, movieGateway)
	userService := service.NewUserService(userRepository)
	revenueService := service.NewRevenueService(bookingRepository, showRepository)

	// instantiate all handlers
	bookingController := controller.NewBookingController(bookingService)
	showController := controller.NewShowController(showService)
	userController := controller.NewUserController(userService)
	revenueController := controller.NewRevenueController(revenueService)

	router := setupApp(cfg)

	authRouter := routerGroupWithAuth(router, userService)
	noAuthRouter := routerGroupWithNoAuth(router)

	booking := authRouter.Group(constants.BookingEndPoint)
	{
		booking.POST("", bookingController.CreateBooking)
	}

	revenue := authRouter.Group(constants.RevenueEndPoint)
	{
		revenue.GET("", revenueController.GetRevenue)
	}

	show := authRouter.Group(constants.ShowEndPoint)
	{
		show.GET("", showController.Shows)
		show.POST("",showController.CreateShow)
	}

	authRouter.GET(constants.LoginEndPoint, userController.Login)

	noAuthRouter.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	err := start(router, cfg.Server)
	if err != nil {
		return err
	}
	return nil
}

func start(r *gin.Engine, cfg appConf.ServerConfig) error {
	s := &http.Server{
		Addr:         port(cfg),
		Handler:      r,
		ReadTimeout:  time.Duration(cfg.ReadTimeout) * time.Second,
		WriteTimeout: time.Duration(cfg.WriteTimeout) * time.Second,
	}
	err := s.ListenAndServe()
	if err != nil {
		return fmt.Errorf("unable to start gin server. error: %w", err)
	}
	return nil
}

func setupApp(cfg appConf.AppConfig) *gin.Engine {
	gin.SetMode(cfg.Server.GineMode)
	engine := gin.New()
	binding.Validator = new(validator.DtoValidator)
	return setupMiddleware(engine, cfg)
}

func setupMiddleware(engine *gin.Engine, cfg appConf.AppConfig) *gin.Engine {
	engine.Use(cors.SetupCORS())
	engine.Use(ginzap.Ginzap(logger.GetLogger(), time.RFC3339, true))
	engine.Use(ginzap.RecoveryWithZap(logger.GetLogger(), true))
	return engine
}

func setAuthMiddleware(rg *gin.RouterGroup, us controller.UserService) *gin.RouterGroup {
	rg.Use(security.Authenticate(us))
	return rg
}

func port(c appConf.ServerConfig) string {
	return fmt.Sprintf(":%d", c.Port)
}

func routerGroupWithAuth(engine *gin.Engine, userService controller.UserService) *gin.RouterGroup {
	authRouter := engine.Group("")
	authRouter = setAuthMiddleware(authRouter, userService)
	return authRouter
}

func routerGroupWithNoAuth(engine *gin.Engine) *gin.RouterGroup {
	noAuthRouter := engine.Group("")
	return noAuthRouter
}



